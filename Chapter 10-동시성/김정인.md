# 동시성

---

- 동시성은 단일 프로세스를 독립적인 컴포넌트로 분리하고, 해당 컴포넌트가 안전하게 데이터를 공유하는 방법을 지정하는 컴퓨터 과학 용어

- 대부분의 언어는 잠금을 획득하여 공유 데이터를 접근하는 운영체제 레벨 스레드를 사용하는 라이브러리를 통해 동시성을 제공한다.

- Go 는 순차적 프로세스들의 통신 (CSP) 에 기반한다.

### CSP 순차적 프로세스 통신

- CSP (Communicating Sequential Process) 는 프로세스 간 통신을 기반으로 하는 병행성 몯레
- 일반적으로 프로세스들이 순차적으로 메시지를 주고 받는 방법
- 공유 데이터를 활용하여 병렬성 프로그래밍을 하는 방법 vs 프로세스 간 순차적 통신을 통해 프로그래밍을 하는 방법


<br />

### 공유데이터 활용 vs CSP

- 공유데이터를 활용하는 방법은 일반적으로 여러 프로세스나 스레드가 동일한 메모리 공간을 공유하고, 이를 통해 데이터 접근과 수정을 진행

- 공유 데이터의 문제점은 동시성 문제가 발생할 수 있음. 
  - 공유데이터에 여러 프로세스나 스레드가 동시에 접근 또는 수정할 때 교착 상태가 발생 할 수 있음
  - 스레드 간 데이터 불일치 문제가 있을 수 있음

- 이를 해결하기 위해 락(lock) 등의 동기화 메커니즘을 사용하여 데이터 일관성을 유지함

- CSP 는 공유 데이터를 직접적으로 공유하지 않고 프로세스 간 통신을 통해 상호 작용을 함

- CSP 는 각 프로세스마다 자체적인 데이터를 가지고 있고, 다른 프로세스와는 명시적인 통신을 통해 데이터를 교환

- CSP 는 프로세스 간 통신을 위해 채널을 사용, 각 채널은 메시지 전달을 위한 통로 역할을 하며, 프로세스는 채널을 통해 메시지를 주고 받음

- CSP 는 공유 데이터를 사용하는 방식에 비해 데드락과 경쟁 조건을 방지하고, 병렬성을 보다 명확하게 다룰 수 있음

<br />

## 동시성 사용 시점

- 프로그램이 동시성을 통해 이점이 있는지 확신해야 한다.

### 동시성과 병렬성의 차이

- 동시성은 여러 작업이 동시에 실행되는 것처럼 보이지만, 사실 여러 작업이 빠르게 번갈아가면서 실행 되는 것을 의미

- 병렬성은 여러 작업이 동시에 실제로 실행되는 것을 의미
- 병렬성은 물리적으로 여러 개의 프로세서 또는 코어를 사용하여 작업을 동시에 처리하는 것

- goroutine 은 경량 쓰레드를 생성하여 Go 런타임이 여러 고루틴을 관리하고 스케줄링 하는 것
- 실제로는 단일 쓰레드에서 번갈아가면서 실행되는 것을 의미한다.


<br />

### Golang 의 Goroutine 은 왜 동시성 으로 만들어졌을까?

- Golang 은 운영체제 수준의 쓰레드보다 훨씬 가벼운 경량 쓰레드를 사용합니다.

- Go 는 Golang 의 런타임을 통해 고루틴을 효율적으로 관리하고, 스케줄링을 합니다.

- 즉 하나의 프로세스에서 경량쓰레드를 활용하여 여러 프로세스가 동시에 작업 효과를 내는 역할을 해냅니다.

- 기존의 쓰레드는 하나의 쓰레드가 하나의 코어에서만 실행되지만, 고루틴은 Golang 의 런타임에 의해 다수의 고루틴이 여러 코어에서 실행될 수 있습니다.

- 따라서 고루틴을 이용하여 병렬로 실행되는 작업을 분산하고 동시에 처리할 수 있으므로, 성능을 극대화할 수 있습니다.

<br />


## 채널

---

- 고루틴은 채널을 통해 통신한다.

- 채널은 맵과 같은 참조타입이기 때문에 채널을 함수로 전달하면 실제로는 채널에 대한 포인터를 전달하는 것이다.


- ``` ch := make(chan int) ```

  ``` a := <- ch```

  ``` ch <- b ```


- 채널에 쓰여진 각 값은 한 번에 하나씩 읽을 수 있다.
  - 다중 고루틴이 같은 채널에서 읽기를 할 경우 채널에 쓰인 하나의 값은 하나의 고루틴에서만 읽을 수 있다.


- 기본적으로 채널은 버퍼가 없다.
  - 채널에 버퍼가 없다는 의미는 채널이 데이터를 보유할 수 있는 공간이 없다는 의미이다.
  - 이런 조류의 채널은 데이터를 받는 측이 준비되지 않으면 데이터를 보낼 수 없다.
  - 때문에 버퍼가 없는 채널은 받는 쪽과 보내는 쪽 2가지의 고루틴을 필요로 한다.

  
- 버퍼가 있는 채널
  
  ``` ch := make(chan(int), 10)```

  - 버퍼가 있는 채널은 할당된 버퍼만큼의 읽기와 쓰기를 진행하지만, 이를 초과하게 되면 블로킹이 된다.
  - ```len``` 함수는 현재 버퍼내에 얼마나 많은 값들이 있는지 알 수 있다.
  - ```cap``` 함수는 해당 채널의 최대 버퍼 크기를 가져올 수 있다.
  

- 채널 닫기

  ``` close(ch) ```

  - 채널을 닫으면 채널에 쓰기를 시도하거나 다시 닫으려 한다면 패닉을 발생시킨다.
  - 그러나 닫힌 채널에 읽기를 시도하는 것은 성공한다.
  - 채널 안에 아직 읽히지 않는 값이 있따면 값들은 순서대로 반환된다.

  ```v, ok := <-ch```
  
  - ok 값은 채널의 닫힘 여부를 알려준다. (true -> open, false -> close)

  - 채널도 변수이기 때문에 사용되지 않으면 GC 가 정리한다.
  
<br />

|  | 버퍼가 없고, 열림 | 버퍼가 없고, 닫힘 | 버퍼가 있고, 열림 | 버퍼가 있고, 닫힘 | Nil |
| --- | --- | --- | --- | --- | --- |
| 읽기 | 뭔가 써질때까지 일시중지 | 제로 값 반환 | 버퍼가 빌 때까지 일시 중지 | 버퍼에 남은 값을 반환, 버퍼가 비어있다면, 제로 값을 반환 | 무한정 대기 |
| 쓰기 | 뭔가 읽을 때까지 일시 중지 | 패닉 | 버퍼가 가득 찰 때까지 일시 중지 | 패닉 | 무한정 대기 |
| 닫기 | 동작함 | 패닉 | 동작함. 남은 값이 있을 수 있음 | 패닉 | 패닉 |

- 여러 고루틴이 같은 채널에 쓰기를 할 때, 같은 채널에 close 를 2번 호출하게 되면 패닉이 발생하게 된다.
- 이러한 문제는 ```sync.WaitGroup``` 을 통해 해결할 수 있다.

<br />

## 채널 대신에 뮤택스를 사용하는 경우

---

- 뮤텍스 : 상호 배제 (mutual exclusion) 의 약어
- 뮤택스는 공유된 데이터의 조각의 접근이나 어떤 코드의 동시 실행을 제한한다.
- 임계 영역 (critical section) 을 보호한다.

- 메모리를 공유하여 통신하지 말고, 통신을 통해 메모리를 공유하자.

<br />

## 채널과 뮤택스 사용의 결정을 도와주기위한 결정 트리

---

- Concurrency in Go 
  - 고루틴들을 조정하고나 고루틴에 의해 변경되는 값을 추적하는 경우에는 채널을 사용하자.
  - 구조체에 항목을 공유하여 접근하는 겨웅에는 뮤텍스를 사용하자.
  - 채널을 사용했을 때 중대한 성능의 문제를 발견했고, 어떤 다른 방법으로도 해당 이슈가 고쳐지지 않는 경우에는 뮤텍스를 사용하여 구현해보도록 하자.

<br />

## 뮤택스는 복사될 수 없다.

---

- sync.WaitGroup 과 sync.Once 와 같이 뮤텍스는 절대로 복사될 수 없다.
- 함수로 전달되거나 구조체의 항목으로 접근된다면 반드시 포인터를 통해야 한다.