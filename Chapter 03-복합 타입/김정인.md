
## 배열

---

- 배열의 선언방법
    - 배열의 크기와 배열 내의 요소 타입을 지정하여 선언하는 방법
        - `var x [3]int`
    - 배열의 초기값을 할당한느 방법
        - `var x = [3]int{10,20,30}`
    - 배열 리터럴을 이용해서 배열을 초기화하는 방법
        - `var x = [...]int{10,20,30}`
    - 다차원 배열 선언 방법
        - `var x [2][3]int`


- 배열의 범위를 넘어서는 값을 가진 변수를 읽거나 쓰게 되면 패닉이 발성하게 된다.


<br />

## 슬라이스

---

- 슬라이스를 선언할 때에 배열처럼 크기를 지정할 필요가 없다.
  - `var x = []int{10, 20, 30}`


- `var x []int` 를 통해 선언되면 이때의 제로 값은 `nil` 값이다.
  - 슬라이스가 nil 인 것은 어떤 요소도 갖고 있지 않다는 것을 의미한다.
  - nil 값을 가진 슬라이스를 `len()` 으로 비교하면 길이 값을 0으로 반환한다.


- append
  - 내장 함수 append 함수는 슬라이스에 새로운 요소를 추가한다.
  - `var x []int` , `x = append(x, 4)` 
  - Go 는 값에 의한 호출 방식을 사용하기 때문에 append 로 전달된 슬라이스는 복사된 값이 함수로 전달된다.
  - 함수 호출에 사용한 변수에 반환된 슬라이스를 다시 재할당 해줘야 한다.
  - Go 의 배열은 값이기 때문에 불변이다. 따라서 재할당만 가능하지, 값을 수정하지는 못한다.

 
- 수용력
  - 슬라이스는 일련의 값을 저한 것
  - 슬라이스의 각 요소는 연속적인 메모리 공간에 할당될 것이며, 이런 할당은 값을 빠르게 읽고 쓰기가 가능하게 한다.
  - 모든 슬라이스는 수용력을 가지는데, 예약된 연속적인 메모리 공간의 크기 값을 가진다.
  - 이 값은 길이 (len) 보다 클 수 있다.
  - 슬라이스가 append 사용으로 수용력 증가가 필요할 때, Go 런타임은 새로운 메모리를 할당한다.
    - 이 때 기존 데이터를 이전 메모리로부터 새로운 메모리로 복사를 하기 위한 시간이 요구된다.
    - 이전에 사용된 메모리는 가비지 컬렉션에서 정리가 필요하다.
    - 때문에 Go 런타임이 슬라이스의 수용력이 다 차면 2배로 증가시킨다.


- make
  - make 는 타입, 길이, 그리고 선택적으로 수용력을 지정하여 슬라이스를 만들 수 있다.
  - `x := make([]int, 5)` , `x := make([]int, 5, 10)`

    
- 슬라이스 선언
  - nil 슬라이스로 만들기 위한 선언 : `var data []int`
  - 슬라이스에 시작 값을 가지거나 슬라이스 값이 변경되지 않는 경우 리터럴로 슬라이스 선언
    - `data := []int{2,4,6,8}`


- 슬라이스의 슬라이싱
  - 슬라이스 연산자는 슬라이스에서 슬라이스를 만들게 한다.
  - 대괄호 내에 콜론(:)으로 구분하여 시작 오프셋과 마지막 오프셋으로 구성하여 사용한다.


```
func main() {
    x := []int{1, 2, 3, 4}
    y := x[:2]
    z := x[1:]
    d := x[1:3]
    e := x[:]

    fmt.Println("x:", x)
    fmt.Println("y:", y)
    fmt.Println("z:", z)
    fmt.Println("d:", d)
    fmt.Println("e:", e)
}

    x: [1 2 3 4]
    y: [1 2]
    z: [2 3 4]
    d: [2 3]
    e: [1 2 3 4]

```


- 슬라이스는 때론 저장 공간을 공유
  - 슬라이스에서 슬라이스를 추출할 때, 실제 데이터의 복사를 만들지 않는다.
  - 대신에, 메모리륵 공유하는 두개의 변수를 가지게 되는 것

<br />

```

func main() {
	fmt.Println("Hello Learning Go")

	x := []int{1, 2, 3, 4}
	y := x[:2]
	fmt.Println(cap(x), cap(y))
	y = append(y, 30)
	fmt.Println("x:", x)
	fmt.Println("y:", y)
}

    4 4
    x: [1 2 30 4]
    y: [1 2 30]

```

- 위의 내용처럼 x 슬라이스를 추출한 y 의 값에 append 를 하면 x 값도 영향을 받게 된다.
- y 슬라이스에 값을 추가하게 되면 위처럼 x 슬라이스 값이 변하게 된다.


- 배열을 슬라이스로 변환
  - 배열로부터 슬라이스를 가져올 수 있다.
  - 배열로부터 슬라이스를 만드는 것은 슬라이싱과 마찬가지로 동일한 메모리 공유 속성을 가지게 된다.


- copy
  - 원본 슬라이스로부터 독립적인 슬라이스를 만들려면 copy 를 사용하면 된다.
  - `num := copy(y,x)`
    - y 는 대상 슬라이스이고, x 는 원본 슬라이스이다.


- 문자열과 룬 그리고 바이트
  - Go 는 문자열을 표현하기 위해 일련의 바이트를 사용한다.
  - Go 의 라이브러리 함수는 문자열이 UTF-8 인코딩으로 구성되어 있다고 간주하고 있다.
  - 문자열도 인덱스를 통해 단일 값을 꺼내올 수 있다.
    - `var s string = "Hello there"` , `var b byte = s[6]`
  - 배열과 슬라이스에서 사용된 슬라이스 표기법은 문자열에서도 통용된다.
    - `var s string = "Hello there"` , `var s2 string = s[4:7]`


