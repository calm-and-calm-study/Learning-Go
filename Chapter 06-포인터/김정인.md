
# 포인터

---

- 포인터는 값이 저장된 메모리의 위치 값을 가지고 있는 변수이다.
- 모든 변수는 하나 혹은 그 이상의 연속적인 메모리 공간에 저장되는데, 그것을 주소라 부른다.
- 서로 다른 타입의 변수들은 서로 다른 양의 메모리를 차지한다.
- 포인터는 단순히 다른 변수가 저장된 주소를 내용으로 가지는 변수이다.


- 포인터의 제로 값은 nil 이다. 
  - 제로값이 nil 인 것은 슬라이스, 맵, 함수, 포인터, 채널, 인터페이스이다.


- Go는 가비지 컬렉터를 가지고 있기 때문에 메모리 관리를 가비지컬렉터가 해준다.


- `&` 는 주소 연산자로, 변수 앞에 `&` 을 붙이면 해당 변수의 값이 저장된 메모리 위치의 주소를 반환한다.
- `*` 는 간접 연산자이다. 포인터 타입의 변수 앞에 붙이면 가리키는 값을 반환한다. 이를 역참조라 부른다.
  - 포인터 역 참조 전에, 포인터가 nil 이 아닌지 확인해야 한다.
  - nil 을 가진 포인터로 역 참조를 시도하면 프로그램은 패닉을 일으킨다.


- 포인터 타입은 포인터가 어떤 타입을 가리키는지 나타낸다.
  - `var x *int


- 내장함수 new 는 포인터 변수를 생성한다.
- 제공된 타입의 제로 값을 가리키는 포인터를 반환한다.
```shell

var x = new(int)
fmt.Println(x == nil)
fmt.Println(*x)

```

- new 함수는 드물게 사용된다.
- 구조체를 위해 포인터 인스턴스를 만들려면 구조체 리터럴 앞에 `&` 를 사용한다.
  - 기본 타입 리터럴이나 상수 앞에는 메모리 주소를 가지지 않기 때문에 `&` 를 사용할 수 없다.


<br />

## 포인터를 두려워 말라

---

- 자바, 파이썬, 자바스크립트, 루비 등 다른 언어에서의 파라미터
  - 클래스의 객체를 함수로 넘기고 해당 클래스 내의 항목 값을 수정하면, 해당 변경은 전달된 변수에 반영이 된다.
  - 파라미터로 재할당이 되면, 해당 변경은 전달된 변수에 반영되지 않는다.
  - nill/null/None 을 파라미터 값으로 전달하면, 파라미터 자체를 새 값으로 설정해도 호출 함수의 변수가 수정되지 않는다.
  

- Go 에서는 값으로 사용할지, 포인터로 사용할지에 대한 선택을 제공한다.


<br />

## 포인터는 변경 가능한 파라미터를 가리킨다.

---

- Go 상수는 컴파일 과정에서 계산될 수 있는 리터럴 표현을 위한 이름을 제공한다.


- 불변의 타입은 버그로부터 조금 더 안전하고, 더 이해하기 쉬우며, 변경에 더 적합하다.
  - 가변의 객체를 사용하는 것은 메서드 내에서 지역적으로 사용하거나, 단 하나의 참조만 있게 사용한다면 나쁘지 않다.
  - Go 는 값에 의한 호출을 사용하는 언어이기 때문에, 함수로 전달된 값은 복사된다.
  - 기본타입, 구조체, 배열과 같은 비 포인터 타입들은 원본을 수정할 수 없다.
  - 호출된 함수는 원본의 복사본을 가지기 때문에 원본의 불변성을 보장한다.


- 포인터가 함수로 전달되면, 함수는 포인터의 복사를 얻게 된다.
  - 해당 포인터는 원본 데이터를 가리키고 있는데, 이는 호출된 함수에서 원본 데이터를 수정할 수 있다는 의미이다.


<br />

## 포인터는 최후의 수단

---

- 포인터들은 데이터 흐름을 이해하기 어렵게 만들며, 가비지 컬렉터에게 추가적인 작업을 준다.
- 함수로 구조체 전달을 포인터로 하여, 항목을 채우는 것보다 함수 내에서 구조체를 초기화하고 반환하는 것이 좋다.

```shell
# Bad Sample
func MakeFoo(f *Foo) error {
	f.Field1 = "val"
	f.Field2 = 20
	return nil
}

# Good Sample
func MakeFoo() (Foo, error) {
	f := Foo{
		Field1: "val",
		Field2: 20,
	}
	return f, nil
}

```


- 변수를 수정하기 위해 포인터 파라미터를 사용해야하는 유일한 경우는 함수가 해당 포인터를 인터페이스로 예상할 때이다.

```shell

f := struct {
	Name string `json:"name"`
	Age int `json:"age"`
}

if err := json.Unmarshal([]byte(`{"name": "Bob", "age":30`), &f); err != nil{
	return err
}

```

- Unmarshal 함수는 JSON 을 포함하는 바이트 슬라이스로부터 변수를 채운다.
- 바이트 슬라이스와 interface{} 파라미터를 받도록 선언되어 있다.
- interface{} 파라미터를 위해 전달된 값은 반드시 포인터여야 한다.
- 함수에서 값을 반환할 때는 값 타입을 사용하는 것을 선호해야 한다.
- 데이터 타입 내에 수정될 필요가 있는 상태 정보를 갖고 있는 경우에만 포인터를 반환 타입으로 사용한다.


### 포인터를 파라미터로 넘기는 것을 지양하도록 하자.


<br />


## 포인터로 성능 개선

---

- 구조체가 충분히 커진다면, 입력 파라미터나 반환값으로 구조체에 대한 포인터를 사용하여 성능을 향상시킬 수 있다.
- 포인터는 모든 데이터 타입을 함수로 전달할 때 상수 시간이 걸리는데, 보통 1나노초 정도이다.
  - 모든 데이터 타입을 위한 포인터의 크기는 항상 동일하기 때문이다.
  - 약 10MB 의 데이터를 전달하는데 약 1 밀리초가 걸린다.

- 그런, 1MB 보다 작은 데이터 구조의 경우 실제로 값 타입으로 반환하는 것보다 포인터 타입으로 반환하는 것이 더 느리다.
  - 100 바이트 데이터를 반환하는데 값 타입은 10 나노초가 걸린다면
  - 포인터는 30 나노초가 걸린다.


<br />

## 제로 값과 값없음의 차이

---

- Go 에서 포인터의 다른 일반적인 사용은 제로 값이 할당된 변수나 항목과 아무런 값도 할당되지 않은 변수나 항목의 차이를 나타낼 수 있다.
- 이런 구분이 프로그램에서 중요하다면 할당되지 않은 변수나 구조체 항목을 나타내기 위해 nil 포인터를 사용하자.
  - nil 포인터를 파라미터나 파라미터의 한 항목으로 넘긴다면, 값을 어디에도 저장할 수 없기 때문에 함수 내에서 값을 설정할 수가 없다는 것을 기억해야 한다.
  - nil 이 아닌 값을 포인터로 전달하더라도 해당 동작을 문서화하지 않는 한 수정하지 않도록 해야 한다.
  - JSON 변환은 예외이다. nil 이 입력 가능한 구조체 항목을 위해 포인터 값을 사용할 수 있다.

<br />


## 맵과 슬라이스의 차이

---

- 함수로 넘겨진 맵의 수정은 넘겨진 원본 변수에 반영이 되었다.
- Go 런타임 내에서 맵은 구조체를 가리키는 포인터로 구현되어 있다.
  - 함수로 맵을 넘기는 것은 포인터를 복사한다는 의미이다.

- 이러한 이유로 특히, 공용 API 에서 입력 파라미터나 반환값으로 맵의 사용을 피해야하는 것이다.
  - API 설계 단계에서 맵은 어떤 값이 포함되어 있는지 알 수 없기 때문에 나쁜 선택이다.
  - 맵에 어떤 키가 있는지 명시적으로 정의하는 것이 없으므로, 그것이 무엇인지 파악하기 위해서는 콛르르 추적해봐야 한다는 것이다.
  - 이러면 API 자체가 문서화가 되는 것을 방해한다.


- Go 는 강한 타입 언어이다.
  - 맵으로 넘기기 보다는 구조체를 사용하도록 한다.


- 반면에, 함수로 슬라이스를 넘기는 것은 조금 더 복잡한 행동을 한다.
  - 슬라이스의 내용을 수정하는 것은 원본 변수에 반영이 되지만 append 를 통해 길이를 변경하는 것은 슬라이스의 수용력이 길이보다 큰 경우 조차도 원본 변수에 반영되지 않는다.
  - 슬라이스는 3개의 항목을 가지는 구조체로 구현이 되어 있기 때문이다.
    - 길이를 위한 정수 항목
    - 수용력을 위한 정수 항목
    - 메모리 블록을 가리키는 포인터
    

- Go 런타임이 원본 슬라이스의 길이를 넘어서서 존재하는 값들은 원본 슬라이스에서 확인할 수 없도록 한다.


- 입력 파라미터로 슬라이스를 사용하는 다른 경우는 재사용이 가능한 버퍼를 위한 것이 가장 이상적이다.


<br />


## 버퍼 슬라이스

---

```shell

r = open_resource()
while r.has_data() {
	data_chunk = r.next_chunk()
	process(data_chunk)
}
close(r)

```

<br />

## 가비지 컬렉션 작업량 줄이기

---

- 버퍼를 사용하는 것은 가비지 컬렉터의 작업량을 줄이는 방법 중 하나이다.
  - 가비지란 더 이상 어떤 포인터도 가리키지 않는 데이터를 의미한다.
  - 어떤 포인터도 가리키지 않는 데이터가 차지하고 있던 메모리는 재사용될 수 있다.
  - 메모리가 복구 되지 않는다면, 프로그램의 메모리 사용량은 컴퓨터의 모든 메모리가 고갈될 때까지 증가할 것이다.
  - 가비지 컬렉터의 역할은 자동으로 사용되지 않은 메모리를 발견하고 재사용할 수 있도록 복구하는 것이다.


- 힙과 스택
  - 스택은 연속적인 블록의 메모리이고 스레드 실행 내에 있는 모든 함수의 호출은 같은 스택을 고융한다.
    - 스택에서 메모리 할당은 빠르고 간단하다.
    - 스택 포인터는 메모리가 할당된 마지막 위치를 추적하면서 추가적인 메모리 할당은 스택 포인터를 이동함으로써 간단히 처리된다.
    - 새로운 스택 프레임이 함수 데이터를 위해 생성된다.
    - 지역 변수들과 함수로 넘어온 파라미터가 스택에 저장된다.
    - 각 새 변수는 값의 크기만큼 스택 포인터를 이동시킨다.
    - 함수가 종료할 때, 함수의 반환값은 스택을 통해 호출 함수로 복사되고 스택 포인터는 종료된 함수를 위한 스택 프레임의 초기 위치로 이동시켜 
    - 함수가 사용한 지역변수와 파라미터는 스택 메모리에서 해제된다.
  
  
- Go 는 프로그램이 실행되는 동안 스택의 크기를 늘릴 수 있다.
- 이는 고루틴이 운영체제가 아니라 Go 런타임에서 관리되기 때문에 가능한 일이다.
- 컴파일 시점에 해당 타입들이 얼마큼의 메모릴르 사용할지를 정확히 알 수 있었다. 
  - 이것이 크기가 배열 타입의 일부로 간주되는 이유이다.
- 배열 크기를 알 수 있기 때문에, 힙 대신 스택에 할당할 수 있다.
- 포인터 타입의 크기도 알고 있기 때문에, 이것 또한 스택에 저장된다.


- 해당 규칙은 포인터가 가리키는 데이터가 들어왔을 때 더 복잡하다.
- Go 에서 포인터가 가리키는 데이터를 스택에 할당하려면 몇가지 조건을 갖추어야 한다.
  - 컴파일 시점에 데이터 크기를 알고 있는 지역 변수여야 한다.
    - 포인터는 함수에서 반환될 수 없다.
  - 포인터가 함수에 전달되면 컴파일러는 이러한 조건이 여전히 유지되는지를 확인할 수 있어야 한다. 


- 컴파일러가 데이터가 스택에 저장될 수 없다고 판단했을 때, 포인터가 가리키는 데이터는 스택을 벗어났고 해당 데이터는 컴파일러가 힙에 저장하게 된다.
- 힙은 가비지 컬렉터에 의해 관리되는 메모리이다. 
  - 스택에서 단순히 스택 포인터를 옮기는 것과는 달리 더 많은 복잡성이 있다.
- 힙에 저장되는 모든 데이터는 스택의 포인터 타입 변수가 접근하는 동안에는 유효하다.
- 더이상 해당 데이터로 가리키는 포인터가 없다면, 그 데이터는 가비지가 되고, 가비지 컬렉터의 작업에서 정리될 것이다.


### 힙에 데이터를 저장하는 것이 나쁜 이유
- 가비지 컬렉터의 작업하는데 시간이 든다.
  - 힙에 있는 사용 가능한 모든 메모리 청크를 추적 유지하거나 메모리 블록이 여전히 유효한 포인터를 가지고 있는지 추적하는 것은 쉬운 일이 아니다.
  - 많은 가비지 컬렉션 알고리즘은 높은 처리량, 낮은 지연을 위해 설계가 된다.

- 컴퓨터 하드웨어 특성을 처리해야 한다.
  - 랩은 메모리를 빠르게 읽기 위해서는 연속적으로 접근해야 한다.
  - Go 에서는 구조체 슬라이스는 모든 데이터가 메모리에 연속적으로 배치된다.
  - 구조체를 가리키는 포인터의 슬라이스는 램 전체에 데이터가 흩어져 있어 읽기 및 처리 속도가 훨씬 느리다.


- 실행 중인 하드웨어를 고려하여 소프트웨어를 작성하는 접근을 기계적 교감이라고 한다.
- Go 가 포인터를 드물게 사용하도록 권장하는 이유는 가능한 많이 스택에 저장하도록 하여 가비지 컬렉터의 작업량을 줄이도록 하는 것이다.
- 구조체의 슬라이스나 기본 타입은 빠른 접근을 위에 메모리에 연속적으로 데이터를 정렬한다.