
# 포인터

---

- 포인터는 값이 저장된 메모리의 위치 값을 가지고 있는 변수이다.
- 모든 변수는 하나 혹은 그 이상의 연속적인 메모리 공간에 저장되는데, 그것을 주소라 부른다.
- 서로 다른 타입의 변수들은 서로 다른 양의 메모리를 차지한다.
- 포인터는 단순히 다른 변수가 저장된 주소를 내용으로 가지는 변수이다.


- 포인터의 제로 값은 nil 이다. 
  - 제로값이 nil 인 것은 슬라이스, 맵, 함수, 포인터, 채널, 인터페이스이다.


- Go는 가비지 컬렉터를 가지고 있기 때문에 메모리 관리를 가비지컬렉터가 해준다.


- `&` 는 주소 연산자로, 변수 앞에 `&` 을 붙이면 해당 변수의 값이 저장된 메모리 위치의 주소를 반환한다.
- `*` 는 간접 연산자이다. 포인터 타입의 변수 앞에 붙이면 가리키는 값을 반환한다. 이를 역참조라 부른다.
  - 포인터 역 참조 전에, 포인터가 nil 이 아닌지 확인해야 한다.
  - nil 을 가진 포인터로 역 참조를 시도하면 프로그램은 패닉을 일으킨다.


- 포인터 타입은 포인터가 어떤 타입을 가리키는지 나타낸다.
  - `var x *int


- 내장함수 new 는 포인터 변수를 생성한다.
- 제공된 타입의 제로 값을 가리키는 포인터를 반환한다.
```shell

var x = new(int)
fmt.Println(x == nil)
fmt.Println(*x)

```

- new 함수는 드물게 사용된다.
- 구조체를 위해 포인터 인스턴스를 만들려면 구조체 리터럴 앞에 `&` 를 사용한다.
  - 기본 타입 리터럴이나 상수 앞에는 메모리 주소를 가지지 않기 때문에 `&` 를 사용할 수 없다.


<br />

## 포인터를 두려워 말라

---

- 자바, 파이썬, 자바스크립트, 루비 등 다른 언어에서의 파라미터
  - 클래스의 객체를 함수로 넘기고 해당 클래스 내의 항목 값을 수정하면, 해당 변경은 전달된 변수에 반영이 된다.
  - 파라미터로 재할당이 되면, 해당 변경은 전달된 변수에 반영되지 않는다.
  - nill/null/None 을 파라미터 값으로 전달하면, 파라미터 자체를 새 값으로 설정해도 호출 함수의 변수가 수정되지 않는다.
  

- Go 에서는 값으로 사용할지, 포인터로 사용할지에 대한 선택을 제공한다.


<br />

## 포인터는 변경 가능한 파라미터를 가리킨다.

---

- Go 상수는 컴파일 과정에서 계산될 수 있는 리터럴 표현을 위한 이름을 제공한다.


- 불변의 타입은 버그로부터 조금 더 안전하고, 더 이해하기 쉬우며, 변경에 더 적합하다.
  - 가변의 객체를 사용하는 것은 메서드 내에서 지역적으로 사용하거나, 단 하나의 참조만 있게 사용한다면 나쁘지 않다.
  - Go 는 값에 의한 호출을 사용하는 언어이기 때문에, 함수로 전달된 값은 복사된다.
  - 기본타입, 구조체, 배열과 같은 비 포인터 타입들은 원본을 수정할 수 없다.
  - 호출된 함수는 원본의 복사본을 가지기 때문에 원본의 불변성을 보장한다.


- 포인터가 함수로 전달되면, 함수는 포인터의 복사를 얻게 된다.
  - 해당 포인터는 원본 데이터를 가리키고 있는데, 이는 호출된 함수에서 원본 데이터를 수정할 수 있다는 의미이다.


<br />

## 포인터는 최후의 수단

---

- 포인터들은 데이터 흐름을 이해하기 어렵게 만들며, 가비지 컬렉터에게 추가적인 작업을 준다.
- 함수로 구조체 전달을 포인터로 하여, 항목을 채우는 것보다 함수 내에서 구조체를 초기화하고 반환하는 것이 좋다.

```shell
# Bad Sample
func MakeFoo(f *Foo) error {
	f.Field1 = "val"
	f.Field2 = 20
	return nil
}

# Good Sample
func MakeFoo() (Foo, error) {
	f := Foo{
		Field1: "val",
		Field2: 20,
	}
	return f, nil
}

```


- 변수를 수정하기 위해 포인터 파라미터를 사용해야하는 유일한 경우는 함수가 해당 포인터를 인터페이스로 예상할 때이다.

```shell

f := struct {
	Name string `json:"name"`
	Age int `json:"age"`
}

if err := json.Unmarshal([]byte(`{"name": "Bob", "age":30`), &f); err != nil{
	return err
}

```

- Unmarshal 함수는 JSON 을 포함하는 바이트 슬라이스로부터 변수를 채운다.
- 바이트 슬라이스와 interface{} 파라미터를 받도록 선언되어 있다.
- interface{} 파라미터를 위해 전달된 값은 반드시 포인터여야 한다.
- 함수에서 값을 반환할 때는 값 타입을 사용하는 것을 선호해야 한다.
- 데이터 타입 내에 수정될 필요가 있는 상태 정보를 갖고 있는 경우에만 포인터를 반환 타입으로 사용한다.


### 포인터를 파라미터로 넘기는 것을 지양하도록 하자.


<br />


## 포인터로 성능 개선

---

- 구조체가 충분히 커진다면, 입력 파라미터나 반환값으로 구조체에 대한 포인터를 사용하여 성능을 향상시킬 수 있다.
- 포인터는 모든 데이터 타입을 함수로 전달할 때 상수 시간이 걸리는데, 보통 1나노초 정도이다.
  - 모든 데이터 타입을 위한 포인터의 크기는 항상 동일하기 때문이다.
  - 약 10MB 의 데이터를 전달하는데 약 1 밀리초가 걸린다.

- 그런, 1MB 보다 작은 데이터 구조의 경우 실제로 값 타입으로 반환하는 것보다 포인터 타입으로 반환하는 것이 더 느리다.
  - 100 바이트 데이터를 반환하는데 값 타입은 10 나노초가 걸린다면
  - 포인터는 30 나노초가 걸린다.


<br />

## 제로 값과 값없음의 차이

---

- Go 에서 포인터의 다른 일반적인 사용은 제로 값이 할당된 변수나 항목과 아무런 값도 할당되지 않은 변수나 항목의 차이를 나타낼 수 있다.
- 이런 구분이 프로그램에서 중요하다면 할당되지 않은 변수나 구조체 항목을 나타내기 위해 nil 포인터를 사용하자.
  - nil 포인터를 파라미터나 파라미터의 한 항목으로 넘긴다면, 값을 어디에도 저장할 수 없기 때문에 함수 내에서 값을 설정할 수가 없다는 것을 기억해야 한다.
  - nil 이 아닌 값을 포인터로 전달하더라도 해당 동작을 문서화하지 않는 한 수정하지 않도록 해야 한다.
  - JSON 변환은 예외이다. nil 이 입력 가능한 구조체 항목을 위해 포인터 값을 사용할 수 있다.