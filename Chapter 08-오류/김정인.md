
# 오류

---

### 오류 처리 방법 : 기초

- Go 는 함수에 마지막 반환 값으로 error 타입의 값을 반환하여 오류를 처리한다.
- 이것은 절대 위반해서는 안되는 관례이다.
- 함수가 예상했던대로 수행이 되면, error 파라미터로 nil 이 반환된다.
- 만약 문제가 있다면 오류 값이 반환된다.
- 오류가 발생하지 않았다는 것을 나타내기 위해 함수에서 nil을 반환하는 이유는 nil 은 모든 인터페이스 타입에 대한 제로 값이기 때문이다.
- Go 는 코드라인이 더 많이 생성되더라도 명확한 코드를 선호한다.

<br />


### 단순 오류에 문자열 사용


- Go 는 문자열로 오류를 생성하는 두 가지 방법을 제공한다.
  - errors.New("")
  - fmt.Errorf("%d isn't an even number", i)
  
<br />


### 센티넬 오류

- 센티넬 오류 : 현재 상태의 문제로 처리를 지속할 수 없음
  - 해당 이름은 컴퓨터 프로그래밍에서 특정 값을 사용하여 더 이상 처리할 수 없다는 것을 나타내는 관행에서 유래됨
  - 센티넬 오류는 패키지 레벨에 선언된 몇 가지 변수 중에 하나
  - 센티넬 오류를 정의하면, 그것은 공개 API 의 일부가 되며, 이후에 모든 이전 버전과 호환되는 배포에서 사용할 수 있도록 해야한다.
  - 더이상 사용할 필요가 없는 특정 상태에 도달했음을 나타내는 오류는 센티넬 오류로 처리한다.

<br />

### 오류는 값이다.

- 오류는 인터페이스이기 때문에, 로깅이나 오류 처리를 위한 추가적 정보를 포함하여 자신만의 오류를 정의할 수 있다.
- 사용자에게 다시 보고해야 하는 오류의 종류를 나타내기 위해 오류의 일부로 상태 코드를 포함할 수 있다.
- 사용자 정의 오류 타입을 정의하는 경우에도 항상 오류 결과를 위한 반환 타입으로 error 를 사용해야 한다.
- 자신만의 오류 타입을 사용한다면, 초기화되지 않은 인스턴스를 반환하지 않도록 주의하자.
- error 를 가지는 모든 지역변수는 error 타입임을 확실하게 해야 한다.


<br />

### 오류 래핑

- 추가 정보를 추가하면서 오류를 유지하는 것을 오류 래핑 (wrapping error) 이라고 한다.
- 일련의 래핑된 오류를 가질 때, 그것은 오류 체인 (error chain) 이라 한다.
- 표준 라이브러리에서 오류를 언래핑 하기 위한 함수를 errors 패키지의 Unwrap 함수를 제공한다.

<br />


### Is 와 As

- 만일 센티널 오류가 래핑되었다면, 확인을 위해 ==를 사용할 수 없으며, 래핑된 사용자 지정 오류와 일치시키기 위해 타입 단언이나 타입 스위치를 사용할 수 없다.
- go 는 errors 패키지에 Is 와 As 를 제공한다.
- errors.Is 함수는 제공된 센티넬 오류와 일치하는 오류 체인에 해당 오류가 있다면 true 를 반환한다.
- errors.As 함수는 반환된 오류가 특정 타입과 일치하는지를 확인할 수 있다.

<br />


### defer 로 오류 래핑

- 같은 오류 메시지가 여러번 호출되는 경우를 defer 함수를 통해 에러가 있을 시 한번 호출되도록 할 수 있다. 

<br />


### 패닉과 복구

- Go 런타임이 다음에 무슨 일이 일어날지 알 수 없는 상황에서 패닉을 발생시킨다.
- 패닉이 발생하면 함수는 즉시 종료되고, 현재 함수에 연결된 모든 defer 함수가 실행을 시작한다.
- defer 가 완료되면 호출 함수에 연결된 defer 가 main 함수에 도달할 때까지 계속 실행된다.

- recover 함수는 패닉을 포착하여 안정적인 종료를 제공하거나 종료를 방지할 수 있는 방법을 제공한다.
- recover 는 패닉을 확인하기 위한 defer 내부에서 호출될 수 있다. 패닉이라면 패닉에 할당된 값이 반환된다. 
- 일단 recover 이 일어나면 실행은 정상적으로 진행된다.

- 즉, 치명적 상황에 대한 panic 을 예약하고 , 이런 상황을 처리할 수 있는 안정적인 방법을 recover 를 통해 해결한다.
  - 패닉이 컴퓨터의 메모리 부족으로 발생했다면, recover 를 사용하여 소프트웨어 모니터링을 위해 상황을 로깅하고, os.Exit(1) 로 종료하여 안전하게 처리한다.
  - 패닉의 요인이 프로그래밍 오류였다면, 계속 진행을 할 수는 있으나 오류를 반환하는 것이 일반적이다.
- 그러나, recover 는 정확히 어떤 오류에 대한 recover 인지 범주할 수 없으므로, 주의해야한다. 우리는 error 를 로깅하고 관리하는 것에 더 집중해야 한다.


