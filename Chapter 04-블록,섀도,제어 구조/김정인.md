
# 블록, 섀도, 제어 구조

---

- 블록과 식별자를 사용할 수 있는 시점을 제어하는 방법
- `if`, `for`, `switch` 와 같은 Go 의 제어문


<br />


## 블록

---

- Go 의 변수를 다양한 곳에서 사용할 수 있다.
  - 변수를 함수 외부에 선언하여 파라미터로 사용할 수 있고, 함수 내의 지역변수로 할 수 있다.


- 블록 : 선언문이 있는 각각의 공간을 블록이라 한다.
  - 함수 외부에서 선언된 변수, 상수, 타입, 함수는 패키지 블록 범위내에 속한다.
  - import 문이 포함된 파일에 유효한 다른 패키지의 이름을 정의한다.
  - 해당 이름들은 파일 블록 내에 있게 된다.
  - 함수의 맨 상위에 선언된 모든 변수들은 블록 내에 있다.
  - 함수 내에서, 모든 중괄호세트는 다른 블록을 정의하여 Go 의 제어 구조가 자체 블록을 정의한다는 것을 볼 수 있다.


- 섀도잉 변수
  - 상위 선언된 변수와 같은 이름의 새로운 변수를 블록 안에 선언힌 변수
  - `:=` 연산자를 사용하는 것은 정확히 어ㄸ너 변수를 대상으로 일어나는지 불명확하기 때문에 피해야 한다.
  - 섀도잉 변수로 미묘한 버그 발생을 방지할 수 있도록 shadow 린터를 설치하여 빌드 프로세스에서 검출할 수 있다.


- Makefile 예시
```shell

vet:
  go vet ./...
  shoadow ./...
.PHONY:vet

```

<br />

## if 문

---

- if 혹은 else 문의 중괄호 내에 선언된 모든 변수는 블록 내에서만 유효하다는 것

```shell

if n := rand.Intn(10); n == 0 {
    fmt.Println("That's too low")
  } else if n > 5 {
    fmt.Println("That's too big:", n)
  } else {
    fmt.Println("That's a good number:", n)
}

```

- 블록 안에서만 유효하고, 밖에서 접근하려면 컴파일 오류를 발생한다.


<br />

## for 문

---

- Go 에서는 `for` 가 유일한 반복문 키워드이다.
  - C 언어와 동일한 방식의 for
  - 조건문만 있는 for
  - 무한루프의 for
  - for-range


- 일반 for 문
```shell

for i := 0; i<10; i++ {
  fmt.Println(i)
}

```

- 조건식만 사용하는 for 문

```shell

for i < 100 {
    fmt.Println(i)
}

```


- for 문을 이용한 무한 루프

```shell

for {
  fmt.Println("Hello")
}

```

- break 와 continue
  - break : for 루프를 바로 빠져나오는 것
  - continue : 루프 중 특정 부분 이하는 바로 수행하지 않고 다음 루프로 넘기는 것

<br />

- for-range 문
  - for-range 루프는 두 개의 변수 index, value 값을 얻는다.

```

for i, v := range evenVals {
    fmt.Println(i, v)
}

```

- 맵 순회

```shell

m := map[string]int {
  "a" : 1,
  "b" : 3, 
  "c" : 2,
}
	
for i:=0; i<3; i++ {
  fmt.Println("Loop", i)
  for k, v := range m {
    fmt.Println(k, v)
  }
}

```

- 출력 시 순서가 보장되지 않고 값이 출력된다.
  - 사람들은 순서가 고정된 것으로 가정하고 코드를 작성하는데, 이는 이상한 시점에 문제를 발생시킬 것이다.
  - 만약 맵이 항상 해시 값을 정확히 동일한 값을 만들고 서버에 맵으로 사용자 데이터를 저장하고 있는 경우라면, 모든 키가 동일한 버킷에 해시되어 특수 제작된 데이터를 보내는 해시도스 공격으로 서버 속도를 느려지게 할 수 있다.


- Go 의 맵 구현 해결법
  - 맵을 위해 해시 알고리즘을 수정하여 맵 변수가 생성될 때마다 무작위의 숫자를 포함하도록 했다.
  - 맵을 for-range 로 순회의 순서를 루프가 반복될 때마다 조금씩 달라지게 했다. 
  - 이 두가지의 변경으로 해시 도스 공격을 더 어렵게 한다.


<br />

- 문자열 순회
  - for-range 로 문자열에 여러 바이트에 걸친 룬을 처리할 때, utf-8 표현을 단일 32 비트 숫자로 변환하고 값에 할당한다.


- for-range 의 값은 복사본

```

evanVals := []int{2, 4, 6, 8, 10}
for _, v := range evanVals {
    v *= 2
}
fmt.Println(evanVals)


print
[2 4 6 8 10]
```

- for range 값은 복사본이기 때문에 evanVals 는 값을 유지한다.


<br />

## Switch 문

---

- Go 의 switch 문의 case 는 아래 case 구분까지 실행 (fall-through) 하지 않는다.
- case 문은 하나의 case 뿐만 아니라 여러 case 를 묶어서 실행 가능하다.
- 비어 있는 case 는 아무 일도 일어나지 않는다.
- switch 문도 비교가 되는 값을 명시하지 않아도 된다.